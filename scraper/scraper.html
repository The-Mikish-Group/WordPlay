<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>WordPlay Level Scraper</title>
<style>
* { margin:0; padding:0; box-sizing:border-box; }
body { font-family: 'Segoe UI', system-ui, sans-serif; background:#1a1a2e; color:#e0e0e0; padding:24px; min-height:100vh; }
h1 { color:#f4a535; margin-bottom:8px; }
.subtitle { opacity:0.6; margin-bottom:24px; }
.controls { display:flex; gap:12px; align-items:end; flex-wrap:wrap; margin-bottom:20px; }
.field { display:flex; flex-direction:column; gap:4px; }
.field label { font-size:12px; opacity:0.6; text-transform:uppercase; letter-spacing:1px; }
.field input, .field select { background:#2a2a4a; border:1px solid #444; color:#fff; padding:8px 12px; border-radius:8px; font-size:14px; width:120px; }
button { padding:10px 20px; border:none; border-radius:8px; font-size:14px; font-weight:700; cursor:pointer; font-family:inherit; }
.btn-start { background:#4CAF50; color:#fff; }
.btn-start:disabled { background:#333; color:#666; cursor:default; }
.btn-stop { background:#f44336; color:#fff; }
.btn-download { background:#2196F3; color:#fff; }
.btn-download:disabled { background:#333; color:#666; cursor:default; }
.stats { display:grid; grid-template-columns:repeat(auto-fit, minmax(140px,1fr)); gap:12px; margin-bottom:20px; }
.stat { background:#2a2a4a; padding:12px; border-radius:10px; text-align:center; }
.stat-val { font-size:24px; font-weight:700; color:#f4a535; }
.stat-label { font-size:11px; opacity:0.5; margin-top:4px; }
.progress-bar { width:100%; height:6px; background:#2a2a4a; border-radius:3px; margin-bottom:20px; overflow:hidden; }
.progress-fill { height:100%; background:linear-gradient(90deg,#f4a535,#4CAF50); border-radius:3px; transition:width 0.3s; }
#log { background:#111; border:1px solid #333; border-radius:10px; padding:12px; height:300px; overflow-y:auto; font-family:'Cascadia Code','Consolas',monospace; font-size:12px; line-height:1.6; }
.log-ok { color:#4CAF50; }
.log-warn { color:#ff9800; }
.log-err { color:#f44336; }
.log-info { color:#2196F3; }
.note { margin-top:16px; padding:12px; background:#2a2a4a; border-radius:8px; font-size:13px; opacity:0.7; }
</style>
</head>
<body>

<h1>üî§ WordPlay Level Scraper</h1>
<p class="subtitle">Scrapes level data from wordscapescheat.com ‚Äî runs entirely in your browser</p>

<div class="controls">
    <div class="field">
        <label>Start Level</label>
        <input type="number" id="startLevel" value="1" min="1">
    </div>
    <div class="field">
        <label>End Level</label>
        <input type="number" id="endLevel" value="150000" min="1">
    </div>
    <div class="field">
        <label>Delay (ms)</label>
        <input type="number" id="delay" value="400" min="100" step="100">
    </div>
    <button class="btn-start" id="btnStart" onclick="startScraping()">‚ñ∂ Start Scraping</button>
    <button class="btn-stop" id="btnStop" onclick="stopScraping()" style="display:none">‚èπ Stop</button>
    <button class="btn-download" id="btnDownload" onclick="downloadAll()" disabled>‚¨á Download JSON</button>
    <button class="btn-download" id="btnExport" onclick="exportChunks()" disabled>üì¶ Export Chunk Files</button>
</div>

<div class="stats">
    <div class="stat"><div class="stat-val" id="sTotal">0</div><div class="stat-label">Levels Scraped</div></div>
    <div class="stat"><div class="stat-val" id="sErrors">0</div><div class="stat-label">Errors</div></div>
    <div class="stat"><div class="stat-val" id="sRate">0</div><div class="stat-label">Levels/min</div></div>
    <div class="stat"><div class="stat-val" id="sCurrent">-</div><div class="stat-label">Current Level</div></div>
    <div class="stat"><div class="stat-val" id="sETA">-</div><div class="stat-label">Est. Remaining</div></div>
    <div class="stat"><div class="stat-val" id="sPct">0%</div><div class="stat-label">Progress</div></div>
</div>

<div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>

<div id="log"></div>

<div class="note">
    <strong>üí° Tips:</strong> Start with a small range to test (e.g., 10100‚Äì10200 for ~100 levels near your game position).
    Progress auto-saves to your browser ‚Äî if you close and reopen, click Start again to resume.
    The scraper fetches the site index first, then individual level pages. Download results anytime.
</div>

<script>
// ============================================================
// WordPlay Browser Scraper
// ============================================================
const BASE = "https://www.wordscapescheat.com";
const DB_NAME = "wordplay-scraper";
const DB_VERSION = 1;
const STORE_LEVELS = "levels";
const STORE_META = "meta";

let db = null;
let running = false;
let groupIndex = null; // [{group, slug, startLevel, endLevel, packs:[{name,slug}]}]
let totalScraped = 0;
let totalErrors = 0;
let startTime = 0;

// ---- IndexedDB ----
function openDB() {
    return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, DB_VERSION);
        req.onupgradeneeded = (e) => {
            const d = e.target.result;
            if (!d.objectStoreNames.contains(STORE_LEVELS)) {
                d.createObjectStore(STORE_LEVELS, { keyPath: "level" });
            }
            if (!d.objectStoreNames.contains(STORE_META)) {
                d.createObjectStore(STORE_META, { keyPath: "key" });
            }
        };
        req.onsuccess = () => { db = req.result; resolve(db); };
        req.onerror = () => reject(req.error);
    });
}

function dbPut(store, data) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction(store, "readwrite");
        tx.objectStore(store).put(data);
        tx.oncomplete = resolve;
        tx.onerror = () => reject(tx.error);
    });
}

function dbGet(store, key) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction(store, "readonly");
        const req = tx.objectStore(store).get(key);
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

function dbGetAll(store) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction(store, "readonly");
        const req = tx.objectStore(store).getAll();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

function dbCount(store) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction(store, "readonly");
        const req = tx.objectStore(store).count();
        req.onsuccess = () => resolve(req.result);
        req.onerror = () => reject(req.error);
    });
}

function dbHas(store, key) {
    return new Promise((resolve, reject) => {
        const tx = db.transaction(store, "readonly");
        const req = tx.objectStore(store).getKey(key);
        req.onsuccess = () => resolve(req.result !== undefined);
        req.onerror = () => reject(req.error);
    });
}

// ---- LOGGING ----
function log(msg, cls = "") {
    const el = document.getElementById("log");
    const line = document.createElement("div");
    line.className = cls;
    const ts = new Date().toLocaleTimeString();
    line.textContent = `[${ts}] ${msg}`;
    el.appendChild(line);
    el.scrollTop = el.scrollHeight;
}

// ---- STATS ----
function updateStats(current, total) {
    const elapsed = (Date.now() - startTime) / 60000; // minutes
    const rate = elapsed > 0 ? (totalScraped / elapsed).toFixed(1) : 0;
    const remaining = total - totalScraped - totalErrors;
    const etaMin = rate > 0 ? Math.ceil(remaining / rate) : 0;
    const etaStr = etaMin > 60 ? `${Math.floor(etaMin/60)}h ${etaMin%60}m` : `${etaMin}m`;
    const pct = total > 0 ? ((totalScraped + totalErrors) / total * 100).toFixed(1) : 0;

    document.getElementById("sTotal").textContent = totalScraped.toLocaleString();
    document.getElementById("sErrors").textContent = totalErrors;
    document.getElementById("sRate").textContent = rate;
    document.getElementById("sCurrent").textContent = current;
    document.getElementById("sETA").textContent = remaining > 0 ? etaStr : "Done";
    document.getElementById("sPct").textContent = pct + "%";
    document.getElementById("progressFill").style.width = pct + "%";
    document.getElementById("btnDownload").disabled = totalScraped === 0;
    document.getElementById("btnExport").disabled = totalScraped === 0;
}

// ---- FETCH WITH CORS PROXY FALLBACK ----
async function fetchPage(url) {
    // Use local ASP.NET proxy (run from Visual Studio at localhost:5001)
    const proxyUrl = `/api/proxy?url=${encodeURIComponent(url)}`;
    const resp = await fetch(proxyUrl, { signal: AbortSignal.timeout(20000) });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    return await resp.text();
}

function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }

// ---- PARSE HOMEPAGE FOR GROUP/PACK INDEX ----
function parseHomepage(html) {
    const index = [];
    // Match sections: ## [GroupName](/answers/slug) ... Levels X-Y ... [Pack](/answers/group/pack)
    const groupPattern = /##\s*\[([^\]]+)\]\(\/answers\/([^)]+)\)[^]*?Levels\s+(\d+)[‚Äì\-](\d+)/g;
    let gm;
    while ((gm = groupPattern.exec(html)) !== null) {
        const groupName = gm[1].trim();
        const groupSlug = gm[2].trim();
        const startLevel = parseInt(gm[3]);
        const endLevel = parseInt(gm[4]);

        // Find packs after this group header until next ## or end
        const afterGroup = html.substring(gm.index + gm[0].length);
        const nextGroup = afterGroup.indexOf("## [");
        const section = nextGroup >= 0 ? afterGroup.substring(0, nextGroup) : afterGroup.substring(0, 500);

        const packs = [];
        const packPat = /\[([^\]]+)\]\(\/answers\/[^/]+\/([^)]+)\)/g;
        let pm;
        while ((pm = packPat.exec(section)) !== null) {
            packs.push({ name: pm[1].trim(), slug: pm[2].trim() });
        }

        if (packs.length > 0) {
            index.push({ group: groupName, slug: groupSlug, startLevel, endLevel, packs });
        }
    }
    return index;
}

// ---- BUILD LEVEL-TO-URL MAPPING ----
function buildLevelMap(index, startLv, endLv) {
    const levels = [];
    for (const g of index) {
        if (g.endLevel < startLv || g.startLevel > endLv) continue;
        const totalLevels = g.endLevel - g.startLevel + 1;
        const levelsPerPack = Math.ceil(totalLevels / g.packs.length);

        let levelNum = g.startLevel;
        for (const pack of g.packs) {
            const packEnd = Math.min(levelNum + levelsPerPack - 1, g.endLevel);
            while (levelNum <= packEnd) {
                if (levelNum >= startLv && levelNum <= endLv) {
                    levels.push({
                        level: levelNum,
                        group: g.group,
                        pack: pack.name,
                        url: `${BASE}/answers/${encodeURIComponent(g.slug)}/${encodeURIComponent(pack.slug)}/${levelNum}`
                    });
                }
                levelNum++;
            }
        }
    }
    return levels;
}

// ---- PARSE INDIVIDUAL LEVEL PAGE ----
function parseLevelPage(html) {
    // Extract letters from text: "letters you can use on this level are 'XXXX'"
    const lm = html.match(/letters you can use on this level are\s*[\u2018\u2019'']([A-Za-z]+)[\u2018\u2019'']/i);
    const letters = lm ? lm[1].toUpperCase() : "";

    // Extract answer words ‚Äî they appear in the ordered list
    // Pattern: listed as "* WORD" in the first list (before "Bonus Words")
    const words = [];
    const bonus = [];

    // Split at "Bonus Words" marker
    const bonusIdx = html.indexOf("Bonus Words");
    const answersSection = bonusIdx >= 0 ? html.substring(0, bonusIdx) : html;
    const bonusSection = bonusIdx >= 0 ? html.substring(bonusIdx) : "";

    // Extract answers: lines like "* WORD" or links like ">WORD</a>"
    const wordPat = /\*\s+([A-Z]{2,})/g;
    let wm;
    while ((wm = wordPat.exec(answersSection)) !== null) {
        const w = wm[1].trim();
        if (w.length >= 2 && !words.includes(w)) words.push(w);
    }

    // Extract bonus words
    const bPat = /\*\s+\[([A-Z]{2,})\]/g;
    let bm;
    while ((bm = bPat.exec(bonusSection)) !== null) {
        const w = bm[1].trim();
        if (w.length >= 2 && !bonus.includes(w)) bonus.push(w);
    }

    // Fallback: try href="/definition/WORD" pattern
    if (words.length === 0) {
        const defPat = /\/definition\/([^"]+)"[^>]*>([^<]+)</gi;
        let dm;
        const allWords = [];
        while ((dm = defPat.exec(html)) !== null) {
            const w = dm[2].trim().toUpperCase();
            if (w.length >= 2 && !allWords.includes(w)) allWords.push(w);
        }
        // First occurrence before bonus = answers, after = bonus
        // Just use all as answers for now
        words.push(...allWords);
    }

    return { letters, words, bonus };
}

// ---- MAIN SCRAPE LOOP ----
async function startScraping() {
    if (running) return;
    running = true;

    document.getElementById("btnStart").style.display = "none";
    document.getElementById("btnStop").style.display = "";

    const startLv = parseInt(document.getElementById("startLevel").value) || 1;
    const endLv = parseInt(document.getElementById("endLevel").value) || 150000;
    const delayMs = parseInt(document.getElementById("delay").value) || 400;

    await openDB();
    totalScraped = await dbCount(STORE_LEVELS);
    totalErrors = 0;
    startTime = Date.now();

    log(`Starting scrape: levels ${startLv} to ${endLv} (delay: ${delayMs}ms)`, "log-info");

    // Step 1: Get or load group index
    const cachedIndex = await dbGet(STORE_META, "groupIndex");
    if (cachedIndex && cachedIndex.data) {
        groupIndex = cachedIndex.data;
        log(`Loaded cached index: ${groupIndex.length} groups`, "log-info");
    } else {
        log("Fetching homepage to build group/pack index...", "log-info");
        try {
            const homepage = await fetchPage(BASE);
            groupIndex = parseHomepage(homepage);
            await dbPut(STORE_META, { key: "groupIndex", data: groupIndex });
            log(`Built index: ${groupIndex.length} groups`, "log-ok");
        } catch (e) {
            log(`Failed to fetch homepage: ${e.message}`, "log-err");
            log("The site may block direct browser requests. Try running from localhost.", "log-warn");
            running = false;
            document.getElementById("btnStart").style.display = "";
            document.getElementById("btnStop").style.display = "none";
            return;
        }
    }

    // Step 2: Build level URLs for requested range
    const levelMap = buildLevelMap(groupIndex, startLv, endLv);
    log(`Mapped ${levelMap.length} levels in range ${startLv}-${endLv}`, "log-info");

    if (levelMap.length === 0) {
        log("No levels found in the requested range.", "log-warn");
        running = false;
        return;
    }

    // Step 3: Scrape each level
    let scraped = 0;
    let errors = 0;
    let skipped = 0;

    for (let i = 0; i < levelMap.length; i++) {
        if (!running) break;

        const meta = levelMap[i];
        
        // Skip already scraped
        if (await dbHas(STORE_LEVELS, meta.level)) {
            skipped++;
            continue;
        }

        try {
            const html = await fetchPage(meta.url);
            const data = parseLevelPage(html);

            if (data.words.length === 0 && data.letters === "") {
                log(`‚ö† Level ${meta.level} (${meta.pack}): no data found`, "log-warn");
                errors++;
                totalErrors++;
            } else {
                await dbPut(STORE_LEVELS, {
                    level: meta.level,
                    group: meta.group,
                    pack: meta.pack,
                    letters: data.letters,
                    words: data.words,
                    bonus: data.bonus
                });
                scraped++;
                totalScraped++;
            }
        } catch (e) {
            log(`‚úó Level ${meta.level}: ${e.message}`, "log-err");
            errors++;
            totalErrors++;
        }

        updateStats(meta.level, levelMap.length - skipped);

        // Log progress periodically
        if ((scraped + errors) % 50 === 0 && (scraped + errors) > 0) {
            log(`Progress: ${totalScraped} scraped, ${errors} errors, ${skipped} skipped ‚Äî Level ${meta.level}`, "log-info");
        }

        // Auto-save checkpoint every 200 levels
        if ((scraped + errors) % 200 === 0) {
            log(`üíæ Auto-checkpoint (${totalScraped} levels in database)`, "log-info");
        }

        await sleep(delayMs);
    }

    log(`\n=== COMPLETE ===`, "log-ok");
    log(`Scraped: ${scraped} | Errors: ${errors} | Skipped: ${skipped} | Total in DB: ${totalScraped}`, "log-ok");
    
    running = false;
    document.getElementById("btnStart").style.display = "";
    document.getElementById("btnStop").style.display = "none";
    updateStats("-", levelMap.length - skipped);
}

function stopScraping() {
    running = false;
    log("Stopping... (will finish current request)", "log-warn");
    document.getElementById("btnStart").style.display = "";
    document.getElementById("btnStop").style.display = "none";
}

// ---- DOWNLOAD ALL AS SINGLE JSON ----
async function downloadAll() {
    await openDB();
    const all = await dbGetAll(STORE_LEVELS);
    all.sort((a, b) => a.level - b.level);

    const data = {};
    for (const lv of all) {
        data[lv.level] = {
            letters: lv.letters,
            words: lv.words,
            bonus: lv.bonus || [],
            group: lv.group,
            pack: lv.pack
        };
    }

    const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = `wordplay-levels-all.json`;
    a.click();
    URL.revokeObjectURL(url);
    log(`Downloaded ${all.length} levels as JSON`, "log-ok");
}

// ---- EXPORT AS CHUNK FILES (for the game app) ----
async function exportChunks() {
    await openDB();
    const all = await dbGetAll(STORE_LEVELS);
    all.sort((a, b) => a.level - b.level);

    const CHUNK = 200;
    const manifest = [];
    const chunks = [];

    for (let i = 0; i < all.length; i += CHUNK) {
        const slice = all.slice(i, i + CHUNK);
        const startLv = slice[0].level;
        const endLv = slice[slice.length - 1].level;
        const fname = `levels-${String(startLv).padStart(6,"0")}-${String(endLv).padStart(6,"0")}.json`;

        const data = {};
        for (const lv of slice) {
            data[lv.level] = [lv.letters, lv.words, lv.group, lv.pack];
        }

        chunks.push({ name: fname, data: JSON.stringify(data) });
        manifest.push({ file: fname, start: startLv, end: endLv });
    }

    // Build pack index
    const packs = [];
    let curGroup = null, curPack = null;
    for (const lv of all) {
        if (lv.group !== curGroup || lv.pack !== curPack) {
            packs.push({ group: lv.group, pack: lv.pack, start: lv.level, end: lv.level });
            curGroup = lv.group;
            curPack = lv.pack;
        } else {
            packs[packs.length - 1].end = lv.level;
        }
    }

    // Create a zip-like bundle (just download a single combined file for simplicity)
    const bundle = {
        manifest: manifest,
        levelIndex: packs,
        chunks: {}
    };
    for (const c of chunks) {
        bundle.chunks[c.name] = JSON.parse(c.data);
    }

    const blob = new Blob([JSON.stringify(bundle)], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "wordplay-data-bundle.json";
    a.click();
    URL.revokeObjectURL(url);
    log(`Exported ${all.length} levels in ${chunks.length} chunks + manifest + index`, "log-ok");
}

// ---- INIT ----
(async function() {
    await openDB();
    totalScraped = await dbCount(STORE_LEVELS);
    if (totalScraped > 0) {
        log(`Found ${totalScraped} previously scraped levels in browser database`, "log-info");
        log("Click Start to resume ‚Äî already-scraped levels will be skipped", "log-info");
        document.getElementById("btnDownload").disabled = false;
        document.getElementById("btnExport").disabled = false;
    }
    document.getElementById("sTotal").textContent = totalScraped.toLocaleString();
})();
</script>

</body>
</html>
